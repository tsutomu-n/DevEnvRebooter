# main.ps1

```ps1
# main.ps1 # # This script manages restarting WSL, browsers, and IDEs. # It needs to be run with administrator privileges. # Import necessary modules Import-Module "$PSScriptRoot\modules\AdminCheck.psm1" -ErrorAction Stop Import-Module "$PSScriptRoot\modules\WslFunctions.psm1" -ErrorAction Stop Import-Module "$PSScriptRoot\modules\BrowserFunctions.psm1" -ErrorAction Stop Import-Module "$PSScriptRoot\modules\IdeFunctions.psm1" -ErrorAction Stop Import-Module "$PSScriptRoot\modules\Logging.psm1" -ErrorAction Stop Import-Module "$PSScriptRoot\modules\Notification.psm1" -ErrorAction Stop Import-Module "$PSScriptRoot\modules\CommonFunctions.psm1" -ErrorAction Stop # Import without displaying the content # Load global configuration file $configPath = "$PSScriptRoot\config.json" $global:config = Get-Content $configPath | ConvertFrom-Json # Manually expand environment variables in config paths $global:config.LOG_DIR = $global:config.LOG_DIR -replace '\${env:USERNAME}', $env:USERNAME $global:config.BROWSERS = $global:config.BROWSERS | ForEach-Object { $_ -replace '\${env:USERNAME}', $env:USERNAME } $global:config.IDES = $global:config.IDES | ForEach-Object { $_ -replace '\${env:USERNAME}', $env:USERNAME } # Check for administrator privileges if (-not (Test-AdminPrivileges)) { Show-ErrorNotification "This script must be run with administrator privileges. Please run PowerShell as an administrator and try again." "Admin Privileges Required" Exit 1 } try { # Ensure the log directory exists $logDir = $global:config.LOG_DIR if (-not (Test-Path $logDir)) { New-Item -ItemType Directory -Path $logDir | Out-Null } # Rotate logs Invoke-LogRotation -logFile "$logDir\$($global:config.LOG_FILE)" # Stop browsers Stop-Applications -Paths $global:config.BROWSERS -Type "Browser" Write-LogInfo "All browsers stopped." # Restart WSL if required if ($global:config.RESTART_WSL) { Restart-WSL Write-LogInfo "WSL restarted successfully." } # Restart IDEs $wslBasedIDEs = $global:config.IDES | Where-Object { $_ -match "wsl" } $nativeIDEs = $global:config.IDES | Where-Object { $_ -notmatch "wsl" } if ($wslBasedIDEs) { Restart-IDE -Paths $wslBasedIDEs -WslBased Write-LogInfo "WSL-based IDEs restarted successfully." } if ($nativeIDEs) { Restart-IDE -Paths $nativeIDEs Write-LogInfo "Native IDEs restarted successfully." } # Start browsers Start-Applications -Paths $global:config.BROWSERS -Type "Browser" Write-LogInfo "All browsers started." # Show completion notification Show-Notification "Restart process completed successfully." "Restart Complete" } catch { # Log errors and show error notification Write-LogError "An error occurred during the restart process." @{Exception=$_.Exception.Message} Show-ErrorNotification "An error occurred during the restart process. Check the logs for details." "Error" }
```

# config.json

```json
{ "RESTART_WAIT_TIME": 2, "LOG_DIR": "C:\\Users\\${env:USERNAME}\\Scripts\\DevEnvRebooter\\logs", "LOG_FILE": "restart_log.txt", "MAX_LOG_SIZE_KB": 1024, "MAX_LOG_BACKUPS": 5, "RESTART_WSL": true, "BROWSERS": [ "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe", "C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe" ], "IDES": [ "C:\\Users\\${env:USERNAME}\\AppData\\Local\\Programs\\cursor\\Cursor.exe", "C:\\Users\\${env:USERNAME}\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe" ] }
```

# User_Guide.md

```md
# User Guide for DevEnvRebooter ## 概要 DevEnvRebooterは、開発環境（WSL、IDE、ブラウザ）の効率的な再起動を行うツールです。並列処理、GUIによる進行状況表示と通知、エラーハンドリングとログ記録、ログファイルのローテーション機能を備えています。 ## 詳細な使用方法 ### 各機能の説明 - **WSL再起動**: WSLの停止と再起動を行います。 - **ブラウザ再起動**: 指定されたブラウザの再起動を行います。 - **IDE再起動**: 指定されたIDEの再起動を行います。 ### 設定ファイルのカスタマイズ `config.json`ファイルを編集して、再起動するアプリケーションのパスを設定します。 \`\`\`json { "RESTART_WAIT_TIME": 2, "BRAVE_PATH": "C:\\Program Files\\BraveSoftware\\Brave-Browser\\Application\\brave.exe", "CURSOR_PATH": "C:\\Users\\${USERNAME}\\AppData\\Local\\Programs\\cursor\\Cursor.exe", "LOG_FILE": "restart_log.txt", "HISTORY_FILE": "restart_history.log", "MAX_RETRIES": 3, "RETRY_WAIT_TIME": 5, "BROWSERS": ["C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe", "C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe"], "IDES": ["C:\\Users\\${USERNAME}\\AppData\\Local\\Programs\\cursor\\Cursor.exe", "C :\\Users\\${USERNAME}\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe"], "LOG_MAX_SIZE_KB": 1024, "LOG_MAX_BACKUPS": 5, "LOG_LEVEL": "Info" } \`\`\` ### チュートリアル 1. **基本的な使用方法** \`\`\`powershell powershell.exe -ExecutionPolicy Bypass -File "C:\Scripts\DevEnvRebooter\main.ps1" \`\`\` 2. **高度な設定** - `config.json`を編集して、再起動するツールやログの設定をカスタマイズします。 - 例: ブラウザやIDEのパスを変更する、ログの保存先を指定する、リトライ回数を設定するなど。 3. **エラーメッセージの解釈方法** - エラーメッセージが表示された場合、以下の手順で解決します。 - **例**: "管理者権限が必要です" 1. PowerShellを右クリックし、「管理者として実行」を選択します。 2. スクリプトを再度実行します。 - **例**: "設定ファイルが無効です" 1. `config.json`の形式やパスを確認します。 2. パスが正しいことを確認し、再度スクリプトを実行します。 ### FAQ 1. **スクリプトを管理者として実行するには？** - PowerShellを右クリックし、「管理者として実行」を選択してください。 2. **ログファイルの場所は？** - デフォルトでは、スクリプトのディレクトリに`restart_log.txt`として保存されます。 3. **設定ファイルをカスタマイズするには？** - `config.json`を編集し、再起動するツールやログの設定を変更します。 4. **特定のツールだけを再起動するには？** - `config.json`で再起動するツールのリストを編集し、不要なツールのパスを削除します。 5. **ログのレベルを変更するには？** - `config.json`で`LOG_LEVEL`を`Info`、`Warning`、`Error`のいずれかに設定します。 ## 高度な使用方法 ### パフォーマンスチューニングのヒント - 再起動待機時間（`RESTART_WAIT_TIME`）を短縮することで、再起動プロセスを高速化できます。 - ログレベル（`LOG_LEVEL`）を調整して、必要な情報のみをログに記録することで、ログファイルのサイズを管理します。 ### コマンドラインオプション - `-ExecutionPolicy Bypass`: スクリプト実行時にスクリプト実行ポリシーをバイパスします。 - `-File`: 実行するスクリプトファイルを指定します。 ### ログファイルの読み方 - `restart_log.txt`には、スクリプト実行中の情報、警告、エラーメッセージが記録されます。 - `restart_history.log`には、スクリプトの実行履歴が記録されます。日付と時間、実行ユーザーが含まれます。 ## スクリーンショットと図 以下に、アプリケーションの動作を視覚的に理解するためのスクリーンショットと図を提供します。 ### メイン画面 ![メイン画面](images/main_screen.png) - **説明**: DevEnvRebooterのメイン画面。ここでWSL、ブラウザ、IDEの再起動が行われます。 ### プログレスバー ![プログレスバー](images/progress_bar.png) - **説明**: 再起動プロセスの進行状況を示すプログレスバー。再起動が完了するまでの進行状況を視覚的に確認できます。 ### エラーメッセージと通知 ![エラーメッセージ](images/error_message.png) - **説明**: エラーメッセージが表示されたときのスクリーンショット。ユーザーがエラーの内容と対処方法を確認できます。 ### 処理フロー図 ![処理フロー図](images/processing_flow.png) - **説明**: アプリケーションの内部処理を示すフローチャート。各モジュール間の関係性とデータの流れが視覚的に理解できます。 ## 参考文献 - [PowerShell Documentation](https://docs.microsoft.com/en-us/powershell/) - [Pester Documentation](https://pester.dev/docs/quick-start) PowerShellスクリプトを管理者として実行するには、以下の手順に従います。 ### 管理者としてPowerShellを実行する手順 1. **スタートメニューを開く**: - Windowsの「スタート」ボタンをクリックします。 2. **PowerShellを検索**: - 検索バーに「PowerShell」と入力します。 3. **管理者として実行**: - 「Windows PowerShell」が表示されたら、それを右クリックします。 - メニューから「管理者として実行」を選択します。 4. **UAC (ユーザーアカウント制御)の確認**: - 「このアプリがデバイスに変更を加えることを許可しますか？」というメッセージが表示されたら、「はい」をクリックします。 5. **スクリプトを実行**: - 管理者権限で開いたPowerShellウィンドウで、スクリプトを実行します。 以下のコマンドを管理者権限のPowerShellウィンドウで実行してください： \`\`\`powershell powershell.exe -ExecutionPolicy Bypass -File "C:\Users\tn\Scripts\DevEnvRebooter\main.ps1" \`\`\` ### 管理者としてPowerShellスクリプトを自動的に実行するショートカットを作成する方法 1. **デスクトップにショートカットを作成**: - デスクトップを右クリックし、「新規作成」→「ショートカット」を選択します。 2. **スクリプトへのパスを入力**: - 「項目の場所を入力してください」のフィールドに以下を入力し、「次へ」をクリックします： \`\`\`plaintext powershell.exe -ExecutionPolicy Bypass -File "C:\Users\tn\Scripts\DevEnvRebooter\main.ps1" \`\`\` 3. **ショートカットの名前を設定**: - ショートカットの名前を入力し、「完了」をクリックします。 4. **ショートカットを管理者として実行する設定**: - 作成したショートカットを右クリックし、「プロパティ」を選択します。 - 「ショートカット」タブで「詳細設定」をクリックします。 - 「管理者として実行」にチェックを入れて「OK」をクリックします。 これで、デスクトップのショートカットをダブルクリックすることで、管理者権限でスクリプトを実行することができます。 ### スクリプトの修正案 スクリプト内で管理者権限をチェックし、管理者権限で再実行するようにすることもできます。以下に、その方法を示します： #### main.ps1の修正 \`\`\`powershell # main.ps1 # This script manages restarting WSL, browsers, and IDEs. # It needs to be run with administrator privileges. # Function to restart script as admin if not already running as admin function Restart-ScriptAsAdmin { $script = [System.Diagnostics.Process]::GetCurrentProcess().MainModule.FileName $arguments = "-NoProfile -ExecutionPolicy Bypass -File `"$($MyInvocation.MyCommand.Path)`"" $startInfo = New-Object System.Diagnostics.ProcessStartInfo $startInfo.FileName = "powershell" $startInfo.Arguments = $arguments $startInfo.Verb = "runas" [System.Diagnostics.Process]::Start($startInfo) | Out-Null exit } # Check for administrator privileges if (-not (Test-AdminPrivileges)) { Show-ErrorNotification "This script must be run with administrator privileges." "Admin Privileges Required" Restart-ScriptAsAdmin Exit 1 } # Import required modules Import-Module "$PSScriptRoot\modules\AdminCheck.psm1" Import-Module "$PSScriptRoot\modules\WslFunctions.psm1" Import-Module "$PSScriptRoot\modules\BrowserFunctions.psm1" Import-Module "$PSScriptRoot\modules\IdeFunctions.psm1" Import-Module "$PSScriptRoot\modules\Logging.psm1" Import-Module "$PSScriptRoot\modules\Notification.psm1" # Load global configuration file $global:config = Get-Content "$PSScriptRoot\config.json" | ConvertFrom-Json try { # Stop browsers foreach ($browser in $global:config.BROWSERS) { Restart-Browser -Path $browser Log-Info "$browser stopped." } # Restart WSL if needed if ($global:config.RESTART_WSL) { Restart-WSL Log-Info "WSL restarted successfully." } # Restart IDEs foreach ($ide in $global:config.IDES) { Restart-IDE -Path $ide -WslBased Log-Info "$ide restarted successfully." } # Start browsers foreach ($browser in $global:config.BROWSERS) { Start-Process -FilePath $browser Log-Info "$browser started." } # Show completion notification Show-Notification "Restart completed successfully." "Restart Complete" } catch { # Log error and show notification Log-Error "An error occurred during the restart process." $_.Exception.Message Show-ErrorNotification "An error occurred during the restart process. Check the log for details." "Error" } \`\`\` これで、スクリプトが自動的に管理者権限で再実行されるようになります。
```

# README.md

```md
# DevEnvRebooter ## 概要 DevEnvRebooterは、開発環境（WSL、IDE、ブラウザ）の効率的な再起動を行うツールです。並列処理、GUIによる進行状況表示と通知、エラーハンドリングとログ記録、ログファイルのローテーション機能を備えています。 ## 主な機能 - WSL、ブラウザ、IDEの並列再起動 - 設定ファイルによるカスタマイズ - ログファイルのローテーション - エラーハンドリングと通知機能 ## 対象ユーザーと使用シーン 開発環境の再起動を頻繁に行う開発者向けのツールです。 ## インストール手順 ### 必要な環境 - PowerShell 5.1 以降 ### インストール方法 1. リポジトリをクローンします。 \`\`\`bash git clone https://github.com/yourusername/DevEnvRebooter.git cd DevEnvRebooter \`\`\` 2. 必要なモジュールをインストールします（必要な場合）。 \`\`\`powershell Install-Module -Name Pester -Scope CurrentUser -Force \`\`\` ## 使用方法 ### 基本的な使用方法 1. `main.ps1`をPowerShellで実行します。 \`\`\`powershell powershell.exe -ExecutionPolicy Bypass -File "C:\Users\tn\Scripts\DevEnvRebooter\main.ps1" \`\`\` ### 設定ファイルの編集方法 `config.json`ファイルを編集して、再起動するアプリケーションのパスやその他の設定をカスタマイズします。 \`\`\`json { "RESTART_WAIT_TIME": 2, "BRAVE_PATH": "C:\\Program Files\\BraveSoftware\\Brave-Browser\\Application\\brave.exe", "CURSOR_PATH": "C:\\Users\\${USERNAME}\\AppData\\Local\\Programs\\cursor\\Cursor.exe", "LOG_FILE": "restart_log.txt", "HISTORY_FILE": "restart_history.log", "MAX_RETRIES": 3, "RETRY_WAIT_TIME": 5, "BROWSERS": ["C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe", "C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe"], "IDES": ["C:\\Users\\${USERNAME}\\AppData\\Local\\Programs\\cursor\\Cursor.exe", "C:\\Users\\${USERNAME}\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe"], "LOG_MAX_SIZE_KB": 1024, "LOG_MAX_BACKUPS": 5, "LOG_LEVEL": "Info" } \`\`\` ### 使用例 1. **基本的な使用例** \`\`\`powershell powershell.exe -ExecutionPolicy Bypass -File "C:\Users\tn\Scripts\DevEnvRebooter\main.ps1" \`\`\` 2. **設定ファイルのカスタマイズ** - `config.json`を編集し、使用するブラウザやIDEのパスを設定します。例えば、Chromeを再起動する場合は以下のように設定します。 \`\`\`json { "BROWSERS": ["C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe"], "IDES": ["C:\\Users\\${USERNAME}\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe"] } \`\`\` ### 一般的なワークフロー 1. **設定ファイルの編集** - `config.json`を開き、再起動するツールのパスや設定をカスタマイズします。 2. **スクリプトの実行** - PowerShellを管理者として実行し、`main.ps1`を実行します。 3. **再起動プロセスの監視** - プログレスバーを確認し、再起動の進行状況を把握します。 4. **エラーメッセージの確認** - エラーが発生した場合、通知ポップアップやログファイルを確認し、問題を解決します。 ### トラブルシューティング - **エラー: 管理者権限が必要です** スクリプトを管理者として実行してください。 - **エラー: 設定ファイルが無効です** 設定ファイルの形式やパスが正しいか確認してください。 ### スクリーンショットと図 以下に、アプリケーションの動作を視覚的に理解するためのスクリーンショットと図を提供します。 ### メイン画面 ![メイン画面](images/main_screen.png) - **説明**: DevEnvRebooterのメイン画面。ここでWSL、ブラウザ、IDEの再起動が行われます。 ### プログレスバー ![プログレスバー](images/progress_bar.png) - **説明**: 再起動プロセスの進行状況を示すプログレスバー。再起動が完了するまでの進行状況を視覚的に確認できます。 ### エラーメッセージと通知 ![エラーメッセージ](images/error_message.png) - **説明**: エラーメッセージが表示されたときのスクリーンショット。ユーザーがエラーの内容と対処方法を確認できます。 ### 処理フロー図 ![処理フロー図](images/processing_flow.png) - **説明**: アプリケーションの内部処理を示すフローチャート。各モジュール間の関係性とデータの流れが視覚的に理解できます。 ## FAQ 1. **スクリプトを管理者として実行するには？** - PowerShellを右クリックし、「管理者として実行」を選択してください。 2. **ログファイルの場所は？** - デフォルトでは、スクリプトのディレクトリに`restart_log.txt`として保存されます。 3. **設定ファイルをカスタマイズするには？** - `config.json`を編集し、再起動するツールやログの設定を変更します。 ## 貢献方法 1. リポジトリをフォークします。 2. 新しいブランチを作成します (`git checkout -b feature/your-feature`)。 3. 変更をコミットします (`git commit -am 'Add some feature'`)。 4. ブランチにプッシュします (`git push origin feature/your-feature`)。 5. プルリクエストを開きます。 ## ライセンス情報 このプロジェクトはMITライセンスの下で公開されています。詳細については、`LICENSE`ファイルを参照してください。 ## バージョン情報 ### バージョン 1.0.0 - 初期リリース ## 更新履歴 ### バージョン 1.0.0 - WSL、ブラウザ、IDEの再起動機能を実装 - ログファイルのローテーション機能を追加 - GUIによる進行状況表示と通知機能を実装 -
```

# Dev_Info.md

```md
## DevEnvRebooter プロジェクトのディレクトリ構造とコード ### ディレクトリ構造 \`\`\` DevEnvRebooter/ │ ├── main.ps1 ├── config.json │ ├── modules/ │ ├── AdminCheck.psm1 │ ├── WslFunctions.psm1 │ ├── BrowserFunctions.psm1 │ ├── IdeFunctions.psm1 │ ├── Logging.psm1 │ └── Notification.psm1 │ └── images/ ├── main_screen.png ├── progress_bar.png ├── error_message.png └── processing_flow.png \`\`\` ### 各ファイルの説明 - **main.ps1**: スクリプトのエントリーポイント。各モジュールを呼び出し、再起動処理を行う。 - **config.json**: 設定ファイル。再起動対象のアプリケーションやログ設定を管理。 - **modules/AdminCheck.psm1**: 管理者権限のチェックを行うモジュール。 - **modules/WslFunctions.psm1**: WSLの再起動機能を提供するモジュール。 - **modules/BrowserFunctions.psm1**: ブラウザの再起動機能を提供するモジュール。 - **modules/IdeFunctions.psm1**: IDEの再起動機能を提供するモジュール。 - **modules/Logging.psm1**: ログ出力とログローテーション機能を提供するモジュール。 - **modules/Notification.psm1**: ユーザー通知機能を提供するモジュール。 - **images/**: ドキュメント用のスクリーンショットや図を保存するディレクトリ。 ### main.ps1 \`\`\`powershell Import-Module "$PSScriptRoot\modules\AdminCheck.psm1" Import-Module "$PSScriptRoot\modules\WslFunctions.psm1" Import-Module "$PSScriptRoot\modules\BrowserFunctions.psm1" Import-Module "$PSScriptRoot\modules\IdeFunctions.psm1" Import-Module "$PSScriptRoot\modules\Logging.psm1" Import-Module "$PSScriptRoot\modules\Notification.psm1" # 設定ファイルの読み込み $configPath = "$PSScriptRoot\config.json" $config = Get-Content $configPath | ConvertFrom-Json # 管理者権限のチェック if (-not (Test-AdminPrivileges)) { Show-ErrorNotification "このスクリプトは管理者権限で実行する必要があります。" "管理者権限が必要です" Exit 1 } # WSLの再起動 if ($config.RESTART_WSL) { try { Restart-WSL Log-Info "WSLの再起動に成功しました。" } catch { Log-Error "WSLの再起動に失敗しました。" $_.Exception.Message } } # ブラウザの再起動 foreach ($browser in $config.BROWSERS) { try { Restart-Browser -Path $browser Log-Info "$browser の再起動に成功しました。" } catch { Log-Error "$browser の再起動に失敗しました。" $_.Exception.Message } } # IDEの再起動 foreach ($ide in $config.IDES) { try { Restart-IDE -Path $ide Log-Info "$ide の再起動に成功しました。" } catch { Log-Error "$ide の再起動に失敗しました。" $_.Exception.Message } } Show-Notification "再起動が完了しました。" "再起動完了" \`\`\` ### config.json \`\`\`json { "RESTART_WAIT_TIME": 2, "BRAVE_PATH": "C:\\Program Files\\BraveSoftware\\Brave-Browser\\Application\\brave.exe", "CURSOR_PATH": "C:\\Users\\${USERNAME}\\AppData\\Local\\Programs\\cursor\\Cursor.exe", "LOG_FILE": "restart_log.txt", "HISTORY_FILE": "restart_history.log", "MAX_RETRIES": 3, "RETRY_WAIT_TIME": 5, "BROWSERS": ["C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe", "C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe"], "IDES": ["C:\\Users\\${USERNAME}\\AppData\\Local\\Programs\\cursor\\Cursor.exe", "C:\\Users\\${USERNAME}\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe"], "LOG_MAX_SIZE_KB": 1024, "LOG_MAX_BACKUPS": 5, "LOG_LEVEL": "Info" } \`\`\` ### modules/AdminCheck.psm1 \`\`\`powershell function Test-AdminPrivileges { $currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent()) return $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator) } \`\`\` ### modules/WslFunctions.psm1 \`\`\`powershell function Restart-WSL { Stop-Process -Name "wsl" -Force -ErrorAction Stop Start-Sleep -Seconds $config.RESTART_WAIT_TIME wsl } \`\`\` ### modules/BrowserFunctions.psm1 \`\`\`powershell function Restart-Browser { param ( [string]$Path ) Stop-Process -Name (Split-Path $Path -Leaf) -Force -ErrorAction Stop Start-Sleep -Seconds $config.RESTART_WAIT_TIME Start-Process -FilePath $Path } \`\`\` ### modules/IdeFunctions.psm1 \`\`\`powershell function Restart-IDE { param ( [string]$Path ) Stop-Process -Name (Split-Path $Path -Leaf) -Force -ErrorAction Stop Start-Sleep -Seconds $config.RESTART_WAIT_TIME Start-Process -FilePath $Path } \`\`\` ### modules/Logging.psm1 \`\`\`powershell function Rotate-LogFile { param ( [string]$logFile, [int]$maxSizeKB = 1024, [int]$maxBackups = 5 ) if ((Get-Item $logFile).Length / 1KB -gt $maxSizeKB) { for ($i = $maxBackups; $i -gt 0; $i--) { $oldFile = "$logFile.$i" $newFile = "$logFile.$($i+1)" if (Test-Path $oldFile) { Move-Item $oldFile $newFile -Force } } Move-Item $logFile "$logFile.1" -Force New-Item $logFile -ItemType File | Out-Null } } function Log-Info { param ([string]$message) $logFile = "$PSScriptRoot\$($config.LOG_FILE)" Rotate-LogFile -logFile $logFile $logMessage = "$(Get-Date) INFO: $message" Write-Host -ForegroundColor Green $logMessage Add-Content -Path $logFile -Value $logMessage } function Log-Error { param ( [string]$technicalMessage, [string]$userMessage ) $logFile = "$PSScriptRoot\$($config.LOG_FILE)" Rotate-LogFile -logFile $logFile $logMessage = "$(Get-Date) ERROR: $technicalMessage" Write-Host -ForegroundColor Red $logMessage Add-Content -Path $logFile -Value $logMessage Show-ErrorNotification $userMessage "エラー発生" } \`\`\` ### modules/Notification.psm1 \`\`\`powershell function Show-Notification { param ( [string]$message, [string]$title = "通知" ) if ($Host.UI.SupportsVirtualTerminal) { Write-Host $message -ForegroundColor Green } else { Add-Type -AssemblyName PresentationFramework [System.Windows.MessageBox]::Show($message, $title, [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Information) | Out-Null } } function Show-ErrorNotification { param ( [string]$message, [string]$title = "エラー" ) if ($Host.UI.SupportsVirtualTerminal) { Write-Host $message -ForegroundColor Red } else { Add-Type -AssemblyName PresentationFramework [System.Windows.MessageBox]::Show($message, $title, [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Error) | Out-Null } } \`\`\` ## 処理フロー図（Mermaid） \`\`\`mermaid graph TD A[開始] --> B[config.jsonを読み込む] B --> C[管理者権限のチェック] C -- 権限なし --> D[エラーメッセージを表示して終了] C -- 権限あり --> E[再起動対象のツールを決定] E --> F{WSLを再起動} F -->|成功| G[ログに再起動成功を記録] F -->|失敗| H[エラーメッセージを表示] G --> I{ブラウザを再起動} H --> I I -->|成功| J[ログに再起動成功を記録] I -->|失敗| K[エラーメッセージを表示] J --> L{IDEを再起動} K --> L L -->|成功| M[ログに再起動成功を記録] L -->|失敗| N[エラーメッセージを表示] M --> O[再起動完了の通知を表示] N --> O O --> P[終了] \`\`\` これで、DevEnvRebooterの全体的なコードとディレクトリ構造が完了しました。この情報を元に、アプリケーションの使用方法や設定方法が簡単に理解できるようになります。
```

# modules/WslFunctions.psm1

```psm1
# WslFunctions.psm1 # # This module contains functions to manage WSL. function Restart-WSL { <# .SYNOPSIS Restarts WSL. .DESCRIPTION This function shuts down and restarts WSL. After restarting, it waits until WSL is fully up and running. .PARAMETER maxRetries Maximum number of retry attempts. .PARAMETER retryWaitTime Wait time between retries in seconds. .PARAMETER wslStartupWaitTime Maximum wait time for WSL to start up in seconds. .OUTPUTS None #> param ( [int]$maxRetries = 3, [int]$retryWaitTime = 5, [int]$wslStartupWaitTime = 30 ) for ($i = 1; $i -le $maxRetries; $i++) { try { Write-Host "Restarting WSL..." wsl --shutdown Start-Sleep -Seconds $global:config.RESTART_WAIT_TIME wsl echo "WSL is starting..." # Wait until WSL is fully up and running $startTime = Get-Date while ($true) { if ((wsl echo "WSL is ready") -eq "WSL is ready") { break } if (((Get-Date) - $startTime).TotalSeconds -gt $wslStartupWaitTime) { throw "WSL startup timed out." } Start-Sleep -Seconds 1 } Write-Host "WSL restarted." return } catch { if ($i -eq $maxRetries) { throw "Failed to restart WSL after $maxRetries attempts." } else { Write-Warning "Failed to restart WSL. Retrying $i/$maxRetries" Start-Sleep -Seconds $retryWaitTime } } } } # Export function Export-ModuleMember -Function Restart-WSL
```

# modules/Notification.psm1

```psm1
# Notification.psm1 # # This module handles user notifications. function Show-Notification { <# .SYNOPSIS Shows a notification using the specified method. .DESCRIPTION This function shows a notification using the specified method (console, popup, or toast). .PARAMETER message The notification message. .PARAMETER title The notification title (default: "Notification"). .PARAMETER method The notification method ("console", "popup", "toast"). .OUTPUTS None #> param ( [string]$message, [string]$title = "Notification", [string]$method = "console" # "console", "popup", "toast" ) switch ($method) { "console" { Write-Host $message -ForegroundColor Green } "popup" { Add-Type -AssemblyName PresentationFramework [System.Windows.MessageBox]::Show($message, $title) } "toast" { New-BurntToastNotification -Text $title, $message } } } function Show-ErrorNotification { <# .SYNOPSIS Shows an error notification. .DESCRIPTION This function shows an error message in a popup. .PARAMETER message The error message. .PARAMETER title The error title. .OUTPUTS None #> param ( [string]$message, [string]$title ) Add-Type -AssemblyName PresentationFramework [System.Windows.MessageBox]::Show($message, $title, [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Error) } # Export functions Export-ModuleMember -Function Show-Notification, Show-ErrorNotification
```

# modules/Logging.psm1

```psm1
# Logging.psm1 # # This module provides logging functions. function Invoke-LogRotation { param ( [string]$logFile, [int]$maxSizeKB = 1024, [int]$maxBackups = 5 ) if ((Get-Item $logFile).Length / 1KB -gt $maxSizeKB) { for ($i = $maxBackups; $i -gt 0; $i--) { $oldFile = "$logFile.$i" $newFile = "$logFile.$($i+1)" if (Test-Path $oldFile) { Move-Item $oldFile $newFile -Force } } Move-Item $logFile "$logFile.1" -Force New-Item -ItemType File -Path $logFile | Out-Null } } function Write-LogMessage { param ( [string]$Level, [string]$Message, [hashtable]$AdditionalInfo = @{} ) $logEntry = @{ Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss" Level = $Level Message = $Message } + $AdditionalInfo $jsonLog = $logEntry | ConvertTo-Json -Compress Add-Content -Path "$global:config.LOG_DIR\$global:config.LOG_FILE" -Value $jsonLog } function Write-LogInfo { param ( [string]$message, [hashtable]$additionalInfo = @{} ) Write-LogMessage -Level "INFO" -Message $message -AdditionalInfo $additionalInfo } function Write-LogError { param ( [string]$message, [hashtable]$additionalInfo = @{} ) Write-LogMessage -Level "ERROR" -Message $message -AdditionalInfo $additionalInfo } # Export the functions in this module Export-ModuleMember -Function Invoke-LogRotation, Write-LogInfo, Write-LogError
```

# modules/IdeFunctions.psm1

```psm1
# IdeFunctions.psm1 # # This module contains functions to manage IDEs. # Import common functions . "$PSScriptRoot\CommonFunctions.psm1" function Restart-IDE { <# .SYNOPSIS Restarts the specified IDE. .DESCRIPTION This function stops and restarts the IDE specified by the given path. If the IDE is WSL-based, it waits until WSL is fully up and running. .PARAMETER Paths The paths to the IDE executables. .PARAMETER WslBased Indicates if the IDE is WSL-based. .OUTPUTS None #> param ( [string[]]$Paths, [switch]$WslBased ) Stop-Applications -Paths $Paths -Type "IDE" if ($WslBased) { # Wait until WSL is fully up and running $wslReady = $false $startTime = Get-Date while (-not $wslReady) { if ((wsl echo "WSL is ready") -eq "WSL is ready") { $wslReady = $true } elseif (((Get-Date) - $startTime).TotalSeconds -gt 60) { Write-Warning "WSL is not ready. Skipping IDE restart." return } Start-Sleep -Seconds 1 } } Start-Applications -Paths $Paths -Type "IDE" } # Export function Export-ModuleMember -Function Restart-IDE
```

# modules/CommonFunctions.psm1

```psm1
# CommonFunctions.psm1 # # This module provides common functions for managing applications. function Stop-Applications { param ( [string[]]$Paths, [string]$Type, [int]$maxRetries = 3, [int]$retryWaitTime = 5 ) foreach ($path in $Paths) { for ($i = 1; $i -le $maxRetries; $i++) { try { $processName = (Split-Path $path -Leaf) -replace '\.exe$','' Stop-Process -Name $processName -Force -ErrorAction Stop Write-Host "$Type ($processName) stopped." break } catch { if ($i -eq $maxRetries) { Write-Warning "Failed to stop $Type ($processName) after $maxRetries attempts." } else { Write-Warning "Failed to stop $Type ($processName). Retrying $i/$maxRetries" Start-Sleep -Seconds $retryWaitTime } } } } } function Start-Applications { param ( [string[]]$Paths, [string]$Type ) foreach ($path in $Paths) { try { Start-Process -FilePath $path Write-Host "$Type ($(Split-Path $path -Leaf)) started." } catch { Write-Warning "Failed to start $Type ($(Split-Path $path -Leaf))." } } } # Export the functions in this module Export-ModuleMember -Function Stop-Applications, Start-Applications
```

# modules/ColorOutput.psm1

```psm1
# ColorOutput.psm1 # # This module provides colorful output functions. function Write-ColoredOutput { param ( [string]$Message, [string]$Color ) switch ($Color) { "Green" { Write-Host $Message -ForegroundColor Green } "Yellow" { Write-Host $Message -ForegroundColor Yellow } "Red" { Write-Host $Message -ForegroundColor Red } "Blue" { Write-Host $Message -ForegroundColor Blue } default { Write-Host $Message } } } # Export functions Export-ModuleMember -Function Write-ColoredOutput
```

# modules/BrowserFunctions.psm1

```psm1
# BrowserFunctions.psm1 # # This module contains functions to manage browsers. # Import common functions . "$PSScriptRoot\CommonFunctions.psm1" function Restart-Browser { <# .SYNOPSIS Restarts the specified browser. .DESCRIPTION This function stops and restarts the browser specified by the given path. .PARAMETER Path The path to the browser executable. .OUTPUTS None #> param ([string]$Path) Stop-Applications -Paths @($Path) -Type "Browser" Start-Applications -Paths @($Path) -Type "Browser" } # Export function Export-ModuleMember -Function Restart-Browser
```

# modules/AdminCheck.psm1

```psm1
# AdminCheck.psm1 # # This module checks if the current user has administrative privileges. function Test-AdminPrivileges { <# .SYNOPSIS Checks if the current user has administrative privileges. .DESCRIPTION This function checks if the current user has administrative privileges. If not, it displays a warning message. .OUTPUTS [bool] True if the user has administrative privileges, otherwise False. #> $currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent()) $isAdmin = $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator) if (-not $isAdmin) { Write-Warning "This script must be run with administrator privileges." Write-Host "Please run PowerShell as an administrator and try again." } return $isAdmin } function Restart-ScriptAsAdmin { <# .SYNOPSIS Restarts the script with administrative privileges. .DESCRIPTION This function restarts the script with administrative privileges. .OUTPUTS None #> if (-not ([Security.Principal.WindowsPrincipal]::new([Security.Principal.WindowsIdentity]::GetCurrent())).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) { $newProcess = New-Object System.Diagnostics.ProcessStartInfo "powershell" $newProcess.Arguments = "-NoProfile -ExecutionPolicy Bypass -File `"" + $MyInvocation.MyCommand.Path + "`"" $newProcess.Verb = "runas" [System.Diagnostics.Process]::Start($newProcess) | Out-Null Exit } } # Export functions Export-ModuleMember -Function Test-AdminPrivileges, Restart-ScriptAsAdmin
```

# images/progress_bar.png

This is a binary file of the type: Image

# images/processing_flow.png

This is a binary file of the type: Image

# images/main_screen.png

This is a binary file of the type: Image

# images/error_message.png

This is a binary file of the type: Image

